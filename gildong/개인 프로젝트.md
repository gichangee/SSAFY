# 개인 프로젝트

java 17

spring boot 3.3.2

# 1. 컨트롤러 생성

1. 간단한 컨트롤러 만들기

```java
@RestController
public class PostController {

		 @GetMapping("/posts")
     public String post(){
        return "Hello World";
    }
}

```

b.  간단한 테스트 만들기

```java
@WebMvcTest
class PostControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    @DisplayName("/posts 요청시 hello world를 출력한다")
    void test() throws Exception {
        //expected
        mockMvc.perform(MockMvcRequestBuilders.get("/posts"))
                .andExpect(MockMvcResultMatchers.status().isOk())
                .andExpect(MockMvcResultMatchers.content().string("Hello World"))
                .andDo(MockMvcResultHandlers.print());
    }
}
```

# 2. POST 데이터 콘텐츠타입

1. 컨트롤러

```java
@Slf4j
@RestController
public class PostController {

		/*
		RequestParam으로 받는 방법
		 @PostMapping("/posts")
     public String post(@RequestParam String title, @RequestParam String content){
        log.info("title ={}, contnent={}",title,content);
        return "Hello World";
    }
    
    Map으로 받는 방법
    @PostMapping("/posts")
     public String post(@RequestParam Map<String,String> params){
        log.info("params={}",params);
        return "Hello World";
    }
    */
    
     @PostMapping("/posts")
     public String post(@RequestBody PostCreate postCreate){
        log.info("postCreate={}",postCreate);
        return "Hello World";
    }
    
}
```

b.   요청 DTO

```java
@toString
@Setter
public class PostCreate {
		private String title;
		private String content;
}

```

c.   테스트

```java
@WebMvcTest
class PostControllerTest {

    @Autowired
    private MockMvc mockMvc;
/*
RequestParam으로 test 
    @Test
    @DisplayName("/posts 요청시 hello world를 출력한다")
    void test() throws Exception {
        //expected
        mockMvc.perform(MockMvcRequestBuilders.post("/posts")
							         .contentType(MediaType.APPLICATION_FORM_URLENCODED)
							         .param("title","글 제목입니다")
							         .param("content","글 내용입니다 하하")
                )
                .andExpect(MockMvcResultMatchers.status().isOk())
                .andExpect(MockMvcResultMatchers.content().string("Hello World"))
                .andDo(MockMvcResultHandlers.print());
    }
*/
	  @Test
    @DisplayName("/posts 요청시 hello world를 출력한다")
    void test() throws Exception {
        //expected
        mockMvc.perform(MockMvcRequestBuilders.post("/posts")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content("{\"title\" : \" 제목입니다.\" , \"content\" : \" 내용입니다.\" }")
                )
                .andExpect(MockMvcResultMatchers.status().isOk())
                .andExpect(MockMvcResultMatchers.content().string("Hello World"))
                .andDo(MockMvcResultHandlers.print());
    }

}
```

# 3. 데이터 검증 - 1

`데이터를 검증하는 이유`

```java
1. client 개발자가 깜빡할 수 있다. 실수로 값을 안보낼 수 있다.
2. client bug로 값이 누락될 수 있다
3. 외부에 나쁜 사람이 값을 임의로 조작해서 보낼수 있따
4. DB에 값을 저장할 때 의도치 않은 오류가 발생할 수 있다
5. 서버 개발자의 편안함을 위해서
```

1. 컨트롤러

```java
@Slf4j
@RestController
public class PostController {

     @PostMapping("/posts")
     public String post(@RequestBody PostCreate postCreate){
        log.info("postCreate={}",postCreate);

        String title = postCreate.getTitle();
        if(title.equals("") || title == null){
            // 1. 빡세다
            // 2. 개발팀 -> 뭔가 3번이상 반복작업을 할때 잘못함을 의심해야함
            // 3. 누락가능성
            // 4. 생각보다 검증해야할게 많다 (꼼뀸하지 않을 수 있따)
            // 5. 뭔가 개발자 스럽지 않다 -> 간지가 안남

            // {"title" : "                "} 이렇게 넘어오면?
            // {"title" : "....수십억 글자"} 이렇게 넘어오면?
            throw new Exception("타이틀 값이 업서요!");
        }

        String content = postCreate.getContent();
        if(content.equals("") || content == null){
            throw new Exception("컨텐트 값이 업서요!");
        }

        // 필드가 수십가지가 있다면 if문을 수십가지 만들어야함
        // 힘듬....

        return "Hello World";
    }
    
}
```

b.   요청 DTO

```java
@toString
@Setter
public class PostCreate {
		private String title;
		private String content;
}

```

c.   테스트

```java
@WebMvcTest
class PostControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    @DisplayName("/posts 요청시 hello world를 출력한다")
    void test() throws Exception {
        //expected
        mockMvc.perform(MockMvcRequestBuilders.post("/posts")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content("{\"title\" : \"\" , \"content\" : \" 내용입니다.\" }")
                )
                .andExpect(MockMvcResultMatchers.status().isOk())
                .andExpect(MockMvcResultMatchers.content().string("Hello World"))
                .andDo(MockMvcResultHandlers.print());
    }

}
```

@`NotBlank` 사용하기

1. 컨트롤러 

```java
@Slf4j
@RestController
public class PostController {
/*
// 만약 title에 공백이 들어오면 스프링에서 컨트롤러 넘어오기 전에 미리 처리를 해줌
// log.info에다가 디버그를 걸어도 거기까지 도달하지 못함
		@PostMapping("/posts")
    public String post(@RequestBody @Valid PostCreate postCreate){    
		    log.info("params ={}",postCreate);
        return "Hello world";
    }

*/
// title 값이 잘못 넘어왔을 때 직접 error를 컨트롤해서 클라이언트에게 error메시지 전달하기
// BindingResult를 사용하기 때문에 에러가 발생해도 메소드 안으로 들어갈 수 있다. 안쓰면 스프링 자체적으로 처리를 함
// body 부분에 json형식으로 에러 메시지가 리턴됨
		@PostMapping("/posts")
    public Map<String,String> post(@RequestBody @Valid PostCreate postCreate, BindingResult result){    
		    if(result.hasErrors()) {
            List<FieldError> errors = result.getFieldErrors();
            FieldError firsterror = errors.get(0);
            String fieldName = firsterror.getField(); //title
            String errorMessage = firsterror.getDefaultMessage(); // 에러메시지

            Map<String, String> error = new HashMap<>();
            error.put(fieldName, errorMessage);
            return error;
        }
        return Map.of();
    }
}
```

b.   요청 DTO

```java
@Getter
@Setter
@ToString
public class PostCreate {

		//공백이랑 null값 둘다 자동으로 검증해줌
    @NotBlank(message = "타이틀을 입력해주세요") // validation 라이브러리 추가해야함
    private String title;

    @NotBlank(message = "컨텐츠를 입력해주세요") // 값이 들어올떄 자동으로 검증해줌 requestbody 옆에 @Valid 붙여야 자동으로 됨
    private String content;
}

```

c.   테스트

```java
@WebMvcTest
class PostControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    @DisplayName("/posts 요청시 hello world를 출력한다")
    void test() throws Exception {
        //expected
        mockMvc.perform(MockMvcRequestBuilders.post("/posts")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content("{\"title\" : null , \"content\" : \" 내용입니다.\" }")
                )
                .andExpect(MockMvcResultMatchers.status().isOk())
                .andExpect(jsonPath("$.title").value("타이틀을 입력해주세요"))
                .andDo(MockMvcResultHandlers.print());
    }
}
```

# 4. 데이터 검증 - 2

BindingResult 사용해서 error 처리하기

  1. 매번 메서드마다 값을 검증해야함
          > 개발자가 까먹을 수 있따.
          > 검증 부분에서 버그가 발생할 여지가 높다
          > 지겹다
   2. 응답값에 HashMap -> 응답 클래스를 만들어주는게 좋습니다
   3. 여러개의 에러처리 힘듬
   4. 세 번이상의 반복적인 작업은 피해야함
   5. 코드 && 개발에 관한 모든것 -> 자동화를 고려해야함

해결 방법 → controllerAdvice 사용하기

1. 컨트롤러

```java
@Slf4j
@RestController
public class PostController {

    @PostMapping("/posts")
    public Map<String,String> post(@RequestBody @Valid PostCreate postCreate) {
        log.info("params ={}",postCreate);
        return Map.of();
    }
}

```

b.   컨트롤러 어드바이스

```java

@Slf4j
@ControllerAdvice
public class ExceptionController {

/* 
		//필드에러를 Map 형식으로 리턴하기
    //BindingResult가 없어야지 이쪽으로 넘어옴
    @ResponseStatus(HttpStatus.BAD_REQUEST) //아래의 에러가 터지면 상태코드를 해당 상태코드로 보냄
    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseBody // -> 리턴데이터를 그대로 응답 본문에 json으로 만들어서 보내도록
    public Map<String, String> MethodArgumentNotValidExceptionHandler(MethodArgumentNotValidException e){
      
        FieldError fieldError = e.getFieldError();
        String field = fieldError.getField();
        String message = fieldError.getDefaultMessage();
        Map<String,String> response = new HashMap<>();
        response.put(field,message);
        return response;

    }
 */
	 //필드 에러에 대한 응답 클래스 따로 만들기
    @ResponseStatus(HttpStatus.BAD_REQUEST) //아래의 에러가 터지면 상태코드를 해당 상태코드로 보냄
    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseBody // -> 리턴데이터를 그대로 응답 본문에 json으로 만들어서 보내도록
    public ErrorResponse MethodArgumentNotValidExceptionHandler(MethodArgumentNotValidException e){
      
			  ErrorResponse response =  new ErrorResponse("400","잘못된 요청입니다");
        for(FieldError fieldError : e.getFieldErrors()){
            response.addValidation(fieldError.getField(),fieldError.getDefaultMessage());
        }

        return response;

    }
}
```

c.   응답 DTO

```java

/**
 * 
 * {
 *     "code" : "400",
 *     "message" : "잘못된 요청입니다",
 *     "validation" : {
 *         "title" : "값을 입력해주세요"
 *     }
 * }
 * 
 */

@Getter
@RequiredArgsConstructor
public class ErrorResponse {
    private final String code;
    private final String message;
    private final Map<String, String> validation = new HashMap<>();

    public void addValidation(String field, String defaultMessage) {
        this.validation.put(field, defaultMessage);
    }

}

```

d.   테스트

```java
@WebMvcTest
class PostControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    @DisplayName("/posts 요청시 title값은 필수다")
    void test2() throws Exception {
        //expected
        mockMvc.perform(MockMvcRequestBuilders.post("/posts")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content("{\"title\" : null , \"content\" : \" 내용입니다.\" }")
                )

                .andExpect(MockMvcResultMatchers.status().isBadRequest())
                .andExpect(jsonPath("$.code").value("400"))
                .andExpect(jsonPath("$.message").value("잘못된 요청입니다"))
                .andExpect(jsonPath("$.validation.title").value("타이틀을 입력해주세요"))
                .andDo(MockMvcResultHandlers.print());
    }

}
```

# 5. 작성글 저장 1 - 게시글 저장 구현

1. 컨트롤러
    
    ```jsx
    
    @Slf4j
    @RestController
    @RequiredArgsConstructor
    public class PostController {
    
        private final PostService postService;
    
        @PostMapping("/posts")
        public Map<String,String> post(@RequestBody @Valid PostCreate request) {
            postService.write(request);
            return Map.of();
        }
    }
    ```
    
2. 서비스
    
    ```jsx
    @Slf4j
    @Service
    @RequiredArgsConstructor
    public class PostService {
    
        private final PostRepository postRepository;
    
        public void write(PostCreate postCreate){
            //postCreat가 Dto 형태이지 엔티티가 아니기에 들어가지지 않음 즉 엔티티로 바꿔야함
            // postCreate --> Entity
            Post post = new Post(postCreate.getTitle(), postCreate.getContent());
            postRepository.save(post);
        }
    }
    
    ```
    
3. 레포지토리
    
    ```jsx
    /*
    첫 번째 타입: <Post> - 이 부분은 이 레포지토리가 다룰 엔티티 클래스의 타입을 지정합니다. 즉, PostRepository는 Post 엔티티와 관련된 데이터베이스 작업을 수행합니다.
    두 번째 타입: <Long> - 이 부분은 해당 엔티티의 ID 타입을 지정합니다. 즉, Post 엔티티의 기본 키가 Long 타입이라는 의미입니다.
    */
    public interface PostRepository extends JpaRepository<Post, Long> {
    }
    
    ```
    
4. 도메인
    
    ```jsx
    @Getter
    @Entity
    @NoArgsConstructor(access = AccessLevel.PROTECTED)
    public class Post {
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private int id;
    
        private String title;
    
        @Lob 
        // 자바에서는 String 타입으로 가지고 있지만 DB에서는 롱 텍스트 형태로 넘어가도록 생성
        // 데이터베이스에서는 이 필드가 일반적인 VARCHAR 타입이 아닌 TEXT, CLOB 등의 형태로 저장될 수 있습니다.
        private String content;
    
        public Post(String title, String content) {
            this.title = title;
            this.content = content;
        }
    }
    ```
    
5. 테스트
    
    ```jsx
    
    //각각의 테스트 메소드들이 절대로 다른 테스트들에게 영향이 가지 않도록 짜는게 중요
    @AutoConfigureMockMvc
    @SpringBootTest
    class PostControllerTest {
    
        @Autowired
        private MockMvc mockMvc;
    
        @Autowired
        private PostRepository postRepository;
    
        @BeforeEach
        void clean(){
            postRepository.deleteAll();
        }
    
        @Test
        @DisplayName("/posts 요청시 hello world를 출력한다")
        void test() throws Exception {
            //expected
            mockMvc.perform(MockMvcRequestBuilders.post("/posts")
                            .contentType(MediaType.APPLICATION_JSON)
                            .content("{\"title\" : \"제목입니다.\" , \"content\" : \" 내용입니다.\" }")
                    )
    
                    .andExpect(MockMvcResultMatchers.status().isOk())
                    .andExpect(MockMvcResultMatchers.content().string("{}"))
                    .andDo(MockMvcResultHandlers.print());
            // db -> post 1개 등록
        }
        @Test
        @DisplayName("/posts 요청시 DB에 값이 저장된다")
        void test3() throws Exception {
            //when
            mockMvc.perform(MockMvcRequestBuilders.post("/posts")
                            .contentType(MediaType.APPLICATION_JSON)
                            .content("{\"title\" : \"제목입니다.\" , \"content\" : \"내용입니다.\" }")
                    )
    
                    .andExpect(MockMvcResultMatchers.status().isOk())
                    .andDo(MockMvcResultHandlers.print());
            //then
            Assertions.assertEquals(1L,postRepository.count());
    
            Post post = postRepository.findAll().get(0);
            Assertions.assertEquals("제목입니다.",post.getTitle());
            Assertions.assertEquals("내용입니다.",post.getContent());
    
        }
    
    }
    ```
    

# 6. 작성글 저장 2 - 클래스 분리

1. 컨트롤러
    
    ```jsx
    
    @Slf4j
    @RestController
    @RequiredArgsConstructor
    public class PostController {
    
        private final PostService postService;
    
        //보통 post 요청이면 응답을 따로 안주는 경우가 많음
        //case1. 저장한 데이터 Entity -> response로 응답하기
        //case2. 저장한 데이터의 primary_id -> response로 응답하기
        //  Client에서는 수신한 id를 글 조회 API를 통해서 데이터를 수신받음
        //case3. 응답 필요없음 -> 클라이언트에서 모든 POST(글) 데이터 context를 잘 관리함
        //bad case : 서버에서 -> 반드시 이렇게 할거임
        //  서버에서 차라리 유연하게 대응하는게 좋음 
        //  한 번에 일괄적으로 잘 처리되는 케이스가 없음
        @PostMapping("/posts")
        public void post(@RequestBody @Valid PostCreate request) {
            postService.write(request);
        }
    
        /*
        @PostMapping("/posts")
        public Post post(@RequestBody @Valid PostCreate request) {
            return postService.write(request);
        }
    
        @PostMapping("/posts")
        public Map post(@RequestBody @Valid PostCreate request) {
            Long postId = postService.write(request);
            return Map.of("postId",postId);
        }
    
         */
    }
    
    ```
    
2. 서비스
    
    ```jsx
    
    @Slf4j
    @Service
    @RequiredArgsConstructor
    public class PostService {
    
        private final PostRepository postRepository;
    
        public void write(PostCreate postCreate){
            //Post post = new Post(postCreate.getTitle(), postCreate.getContent());
            Post post = Post.builder()
                    .title(postCreate.getTitle())
                    .content(postCreate.getContent())
                    .build();
            postRepository.save(post);
        }
    }
    ```
    
3. 도메인
    
    ```jsx
    
    @Getter
    @Entity
    @NoArgsConstructor(access = AccessLevel.PROTECTED)
    public class Post {
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private int id;
    
        private String title;
    
        @Lob
        private String content;
    
        @Builder
        public Post(String title, String content) {
            this.title = title;
            this.content = content;
        }
    }
    
    ```
    
4. Dto
    
    ```jsx
    
    @Getter
    @Setter
    @ToString
    public class PostCreate {
    
        @NotBlank(message = "타이틀을 입력해주세요") // validation 라이브러리 추가해야함
        private String title;
    
        @NotBlank(message = "컨텐츠를 입력해주세요") // 값이 들어올떄 자동으로 검증해줌 requestbody 옆에 @Valid 붙여야 자동으로 됨
        private String content;
    
        //생성자를 사용하면 매개변수 위치가 바뀌어버리면 버그를 발견하기 굉장히 어려워짐
        //그렇기에 @Builder를 사용한다
        //빌더는 생성자에다가 다는 것이 좋다
        //빌더를 클래스위에다가 달고 @NoArgsConstructor를 달면 빌더가 망가짐
        @Builder
        public PostCreate(String title, String content) {
            this.title = title;
            this.content = content;
        }
    
        /*
        빌더의 장점
        가독성이 좋다(값 생성에 대한 유연함)
        필요한 값만 받을 수 있다
        객체의 불변성
         */
    }
    
    @Getter
    public class ErrorResponse {
        private final String code;
        private final String message;
        private final Map<String, String> validation = new HashMap<>();
    
        public void addValidation(String field, String defaultMessage) {
            this.validation.put(field, defaultMessage);
        }
    
        @Builder
        public ErrorResponse(String code, String message) {
            this.code = code;
            this.message = message;
        }
    }
    ```
    
5. 테스트
    
    ```jsx
    @AutoConfigureMockMvc
    @SpringBootTest
    class PostControllerTest {
    
        @Autowired
        private ObjectMapper objectMapper;
    
        @Autowired
        private MockMvc mockMvc;
    
        @Autowired
        private PostRepository postRepository;
    
        @BeforeEach
        void clean(){
            postRepository.deleteAll();
        }
    
        @Test
        @DisplayName("/posts 요청시 hello world를 출력한다")
        void test() throws Exception {
            //given
            //PostCreate request = new PostCreate("제목입니다.","내용입니다.");
            PostCreate request = PostCreate.builder()
                    .title("제목입니다.")
                    .content("내용입니다.")
                    .build();
    
            //mapper 객체의 writeValueAsString 메서드는 Java 객체를 JSON 문자열로 변환합니다.
            String json = objectMapper.writeValueAsString(request);
    
            //expected
            mockMvc.perform(MockMvcRequestBuilders.post("/posts")
                            .contentType(MediaType.APPLICATION_JSON)
                            //.content("{\"title\" : \"제목입니다.\" , \"content\" : \" 내용입니다.\" }")
                            //개발자가 읽기도 쓰기도 힘듬
                            //content() 안에는 byte랑 string만 넣을 수 있다
                            .content(json)
                    )
    
                    .andExpect(MockMvcResultMatchers.status().isOk())
                    .andExpect(MockMvcResultMatchers.content().string(""))
                    .andDo(MockMvcResultHandlers.print());
        }
    
        @Test
        @DisplayName("/posts 요청시 title값은 필수다")
        void test2() throws Exception {
            //given
            PostCreate request = PostCreate.builder()
                    .content("내용입니다.") // title을 안 넘기면 null값이 넘어감
                    .build();
    
            String json = objectMapper.writeValueAsString(request);
            //expected
            mockMvc.perform(MockMvcRequestBuilders.post("/posts")
                            .contentType(MediaType.APPLICATION_JSON)
                            .content(json)
                    )
    
                    .andExpect(MockMvcResultMatchers.status().isBadRequest())
                    .andExpect(jsonPath("$.code").value("400"))
                    .andExpect(jsonPath("$.message").value("잘못된 요청입니다"))
                    .andExpect(jsonPath("$.validation.title").value("타이틀을 입력해주세요"))
                    .andDo(MockMvcResultHandlers.print());
        }
    
        @Test
        @DisplayName("/posts 요청시 DB에 값이 저장된다")
        void test3() throws Exception {
            //given
            PostCreate request = PostCreate.builder()
                    .title("제목입니다.")
                    .content("내용입니다.") // title을 안 넘기면 null값이 넘어감
                    .build();
    
            String json = objectMapper.writeValueAsString(request);
            //when
            mockMvc.perform(MockMvcRequestBuilders.post("/posts")
                            .contentType(MediaType.APPLICATION_JSON)
                            .content(json)
                    )
    
                    .andExpect(MockMvcResultMatchers.status().isOk())
                    .andDo(MockMvcResultHandlers.print());
            //then
            Assertions.assertEquals(1L,postRepository.count());
    
            Post post = postRepository.findAll().get(0);
            Assertions.assertEquals("제목입니다.",post.getTitle());
            Assertions.assertEquals("내용입니다.",post.getContent());
    
        }
    
    }
    ```
    
6. Exception 컨트롤러
    
    ```jsx
    
    @Slf4j
    @ControllerAdvice
    public class ExceptionController {
    
        @ResponseStatus(HttpStatus.BAD_REQUEST)
        @ExceptionHandler(MethodArgumentNotValidException.class)
        @ResponseBody
        public  ErrorResponse MethodArgumentNotValidExceptionHandler(MethodArgumentNotValidException e){
    
            //ErrorResponse response =  new ErrorResponse("400","잘못된 요청입니다");
    
            ErrorResponse response = ErrorResponse.builder()
                    .code("400")
                    .message("잘못된 요청입니다")
                    .build();
            
            for(FieldError fieldError : e.getFieldErrors()){
                response.addValidation(fieldError.getField(),fieldError.getDefaultMessage());
            }
    
            return response;
    
        }
    }
    
    ```
    

# 7. 게시글 조회 1 - 단건조회
