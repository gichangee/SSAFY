# 개인 프로젝트

java 17

spring boot 3.3.2

# 1. 컨트롤러 생성

1. 간단한 컨트롤러 만들기

```java
@RestController
public class PostController {

		 @GetMapping("/posts")
     public String post(){
        return "Hello World";
    }
}

```

b.  간단한 테스트 만들기

```java
@WebMvcTest
class PostControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    @DisplayName("/posts 요청시 hello world를 출력한다")
    void test() throws Exception {
        //expected
        mockMvc.perform(MockMvcRequestBuilders.get("/posts"))
                .andExpect(MockMvcResultMatchers.status().isOk())
                .andExpect(MockMvcResultMatchers.content().string("Hello World"))
                .andDo(MockMvcResultHandlers.print());
    }
}
```

# 2. POST 데이터 콘텐츠타입

1. 컨트롤러

```java
@Slf4j
@RestController
public class PostController {

		/*
		RequestParam으로 받는 방법
		 @PostMapping("/posts")
     public String post(@RequestParam String title, @RequestParam String content){
        log.info("title ={}, contnent={}",title,content);
        return "Hello World";
    }
    
    Map으로 받는 방법
    @PostMapping("/posts")
     public String post(@RequestParam Map<String,String> params){
        log.info("params={}",params);
        return "Hello World";
    }
    */
    
     @PostMapping("/posts")
     public String post(@RequestBody PostCreate postCreate){
        log.info("postCreate={}",postCreate);
        return "Hello World";
    }
    
}
```

b.   요청 DTO

```java
@toString
@Setter
public class PostCreate {
		private String title;
		private String content;
}

```

c.   테스트

```java
@WebMvcTest
class PostControllerTest {

    @Autowired
    private MockMvc mockMvc;
/*
RequestParam으로 test 
    @Test
    @DisplayName("/posts 요청시 hello world를 출력한다")
    void test() throws Exception {
        //expected
        mockMvc.perform(MockMvcRequestBuilders.post("/posts")
							         .contentType(MediaType.APPLICATION_FORM_URLENCODED)
							         .param("title","글 제목입니다")
							         .param("content","글 내용입니다 하하")
                )
                .andExpect(MockMvcResultMatchers.status().isOk())
                .andExpect(MockMvcResultMatchers.content().string("Hello World"))
                .andDo(MockMvcResultHandlers.print());
    }
*/
	  @Test
    @DisplayName("/posts 요청시 hello world를 출력한다")
    void test() throws Exception {
        //expected
        mockMvc.perform(MockMvcRequestBuilders.post("/posts")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content("{\"title\" : \" 제목입니다.\" , \"content\" : \" 내용입니다.\" }")
                )
                .andExpect(MockMvcResultMatchers.status().isOk())
                .andExpect(MockMvcResultMatchers.content().string("Hello World"))
                .andDo(MockMvcResultHandlers.print());
    }

}
```

# 3. 데이터 검증 - 1

`데이터를 검증하는 이유`

```java
1. client 개발자가 깜빡할 수 있다. 실수로 값을 안보낼 수 있다.
2. client bug로 값이 누락될 수 있다
3. 외부에 나쁜 사람이 값을 임의로 조작해서 보낼수 있따
4. DB에 값을 저장할 때 의도치 않은 오류가 발생할 수 있다
5. 서버 개발자의 편안함을 위해서
```

1. 컨트롤러

```java
@Slf4j
@RestController
public class PostController {

     @PostMapping("/posts")
     public String post(@RequestBody PostCreate postCreate){
        log.info("postCreate={}",postCreate);

        String title = postCreate.getTitle();
        if(title.equals("") || title == null){
            // 1. 빡세다
            // 2. 개발팀 -> 뭔가 3번이상 반복작업을 할때 잘못함을 의심해야함
            // 3. 누락가능성
            // 4. 생각보다 검증해야할게 많다 (꼼뀸하지 않을 수 있따)
            // 5. 뭔가 개발자 스럽지 않다 -> 간지가 안남

            // {"title" : "                "} 이렇게 넘어오면?
            // {"title" : "....수십억 글자"} 이렇게 넘어오면?
            throw new Exception("타이틀 값이 업서요!");
        }

        String content = postCreate.getContent();
        if(content.equals("") || content == null){
            throw new Exception("컨텐트 값이 업서요!");
        }

        // 필드가 수십가지가 있다면 if문을 수십가지 만들어야함
        // 힘듬....

        return "Hello World";
    }
    
}
```

b.   요청 DTO

```java
@toString
@Setter
public class PostCreate {
		private String title;
		private String content;
}

```

c.   테스트

```java
@WebMvcTest
class PostControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    @DisplayName("/posts 요청시 hello world를 출력한다")
    void test() throws Exception {
        //expected
        mockMvc.perform(MockMvcRequestBuilders.post("/posts")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content("{\"title\" : \"\" , \"content\" : \" 내용입니다.\" }")
                )
                .andExpect(MockMvcResultMatchers.status().isOk())
                .andExpect(MockMvcResultMatchers.content().string("Hello World"))
                .andDo(MockMvcResultHandlers.print());
    }

}
```

@`NotBlank` 사용하기

1. 컨트롤러 

```java
@Slf4j
@RestController
public class PostController {
/*
// 만약 title에 공백이 들어오면 스프링에서 컨트롤러 넘어오기 전에 미리 처리를 해줌
// log.info에다가 디버그를 걸어도 거기까지 도달하지 못함
		@PostMapping("/posts")
    public String post(@RequestBody @Valid PostCreate postCreate){    
		    log.info("params ={}",postCreate);
        return "Hello world";
    }

*/
// title 값이 잘못 넘어왔을 때 직접 error를 컨트롤해서 클라이언트에게 error메시지 전달하기
// BindingResult를 사용하기 때문에 에러가 발생해도 메소드 안으로 들어갈 수 있다. 안쓰면 스프링 자체적으로 처리를 함
// body 부분에 json형식으로 에러 메시지가 리턴됨
		@PostMapping("/posts")
    public Map<String,String> post(@RequestBody @Valid PostCreate postCreate, BindingResult result){    
		    if(result.hasErrors()) {
            List<FieldError> errors = result.getFieldErrors();
            FieldError firsterror = errors.get(0);
            String fieldName = firsterror.getField(); //title
            String errorMessage = firsterror.getDefaultMessage(); // 에러메시지

            Map<String, String> error = new HashMap<>();
            error.put(fieldName, errorMessage);
            return error;
        }
        return Map.of();
    }
}
```

b.   요청 DTO

```java
@Getter
@Setter
@ToString
public class PostCreate {

		//공백이랑 null값 둘다 자동으로 검증해줌
    @NotBlank(message = "타이틀을 입력해주세요") // validation 라이브러리 추가해야함
    private String title;

    @NotBlank(message = "컨텐츠를 입력해주세요") // 값이 들어올떄 자동으로 검증해줌 requestbody 옆에 @Valid 붙여야 자동으로 됨
    private String content;
}

```

c.   테스트

```java
@WebMvcTest
class PostControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    @DisplayName("/posts 요청시 hello world를 출력한다")
    void test() throws Exception {
        //expected
        mockMvc.perform(MockMvcRequestBuilders.post("/posts")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content("{\"title\" : null , \"content\" : \" 내용입니다.\" }")
                )
                .andExpect(MockMvcResultMatchers.status().isOk())
                .andExpect(jsonPath("$.title").value("타이틀을 입력해주세요"))
                .andDo(MockMvcResultHandlers.print());
    }
}
```

# 4. 데이터 검증 - 2

BindingResult 사용해서 error 처리하기

  1. 매번 메서드마다 값을 검증해야함
          > 개발자가 까먹을 수 있따.
          > 검증 부분에서 버그가 발생할 여지가 높다
          > 지겹다
   2. 응답값에 HashMap -> 응답 클래스를 만들어주는게 좋습니다
   3. 여러개의 에러처리 힘듬
   4. 세 번이상의 반복적인 작업은 피해야함
   5. 코드 && 개발에 관한 모든것 -> 자동화를 고려해야함

해결 방법 → controllerAdvice 사용하기

1. 컨트롤러

```java
@Slf4j
@RestController
public class PostController {

    @PostMapping("/posts")
    public Map<String,String> post(@RequestBody @Valid PostCreate postCreate) {
        log.info("params ={}",postCreate);
        return Map.of();
    }
}

```

b.   컨트롤러 어드바이스

```java

@Slf4j
@ControllerAdvice
public class ExceptionController {

/* 
		//필드에러를 Map 형식으로 리턴하기
    //BindingResult가 없어야지 이쪽으로 넘어옴
    @ResponseStatus(HttpStatus.BAD_REQUEST) //아래의 에러가 터지면 상태코드를 해당 상태코드로 보냄
    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseBody // -> 리턴데이터를 그대로 응답 본문에 json으로 만들어서 보내도록
    public Map<String, String> MethodArgumentNotValidExceptionHandler(MethodArgumentNotValidException e){
      
        FieldError fieldError = e.getFieldError();
        String field = fieldError.getField();
        String message = fieldError.getDefaultMessage();
        Map<String,String> response = new HashMap<>();
        response.put(field,message);
        return response;

    }
 */
	 //필드 에러에 대한 응답 클래스 따로 만들기
    @ResponseStatus(HttpStatus.BAD_REQUEST) //아래의 에러가 터지면 상태코드를 해당 상태코드로 보냄
    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseBody // -> 리턴데이터를 그대로 응답 본문에 json으로 만들어서 보내도록
    public ErrorResponse MethodArgumentNotValidExceptionHandler(MethodArgumentNotValidException e){
      
			  ErrorResponse response =  new ErrorResponse("400","잘못된 요청입니다");
        for(FieldError fieldError : e.getFieldErrors()){
            response.addValidation(fieldError.getField(),fieldError.getDefaultMessage());
        }

        return response;

    }
}
```

c.   응답 DTO

```java

/**
 * 
 * {
 *     "code" : "400",
 *     "message" : "잘못된 요청입니다",
 *     "validation" : {
 *         "title" : "값을 입력해주세요"
 *     }
 * }
 * 
 */

@Getter
@RequiredArgsConstructor
public class ErrorResponse {
    private final String code;
    private final String message;
    private final Map<String, String> validation = new HashMap<>();

    public void addValidation(String field, String defaultMessage) {
        this.validation.put(field, defaultMessage);
    }

}

```

d.   테스트

```java
@WebMvcTest
class PostControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    @DisplayName("/posts 요청시 title값은 필수다")
    void test2() throws Exception {
        //expected
        mockMvc.perform(MockMvcRequestBuilders.post("/posts")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content("{\"title\" : null , \"content\" : \" 내용입니다.\" }")
                )

                .andExpect(MockMvcResultMatchers.status().isBadRequest())
                .andExpect(jsonPath("$.code").value("400"))
                .andExpect(jsonPath("$.message").value("잘못된 요청입니다"))
                .andExpect(jsonPath("$.validation.title").value("타이틀을 입력해주세요"))
                .andDo(MockMvcResultHandlers.print());
    }

}
```

# 5. 작성글 저장 1 - 게시글 저장 구현

1. 컨트롤러
    
    ```jsx
    
    @Slf4j
    @RestController
    @RequiredArgsConstructor
    public class PostController {
    
        private final PostService postService;
    
        @PostMapping("/posts")
        public Map<String,String> post(@RequestBody @Valid PostCreate request) {
            postService.write(request);
            return Map.of();
        }
    }
    ```
    
2. 서비스
    
    ```jsx
    @Slf4j
    @Service
    @RequiredArgsConstructor
    public class PostService {
    
        private final PostRepository postRepository;
    
        public void write(PostCreate postCreate){
            //postCreat가 Dto 형태이지 엔티티가 아니기에 들어가지지 않음 즉 엔티티로 바꿔야함
            // postCreate --> Entity
            Post post = new Post(postCreate.getTitle(), postCreate.getContent());
            postRepository.save(post);
        }
    }
    
    ```
    
3. 레포지토리
    
    ```jsx
    /*
    첫 번째 타입: <Post> - 이 부분은 이 레포지토리가 다룰 엔티티 클래스의 타입을 지정합니다. 즉, PostRepository는 Post 엔티티와 관련된 데이터베이스 작업을 수행합니다.
    두 번째 타입: <Long> - 이 부분은 해당 엔티티의 ID 타입을 지정합니다. 즉, Post 엔티티의 기본 키가 Long 타입이라는 의미입니다.
    */
    public interface PostRepository extends JpaRepository<Post, Long> {
    }
    
    ```
    
4. 도메인
    
    ```jsx
    @Getter
    @Entity
    @NoArgsConstructor(access = AccessLevel.PROTECTED)
    public class Post {
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;
    
        private String title;
    
        @Lob 
        // 자바에서는 String 타입으로 가지고 있지만 DB에서는 롱 텍스트 형태로 넘어가도록 생성
        // 데이터베이스에서는 이 필드가 일반적인 VARCHAR 타입이 아닌 TEXT, CLOB 등의 형태로 저장될 수 있습니다.
        private String content;
    
        public Post(String title, String content) {
            this.title = title;
            this.content = content;
        }
    }
    ```
    
5. 테스트
    
    ```jsx
    
    //각각의 테스트 메소드들이 절대로 다른 테스트들에게 영향이 가지 않도록 짜는게 중요
    @AutoConfigureMockMvc
    @SpringBootTest
    class PostControllerTest {
    
        @Autowired
        private MockMvc mockMvc;
    
        @Autowired
        private PostRepository postRepository;
    
        @BeforeEach
        void clean(){
            postRepository.deleteAll();
        }
    
        @Test
        @DisplayName("/posts 요청시 hello world를 출력한다")
        void test() throws Exception {
            //expected
            mockMvc.perform(MockMvcRequestBuilders.post("/posts")
                            .contentType(MediaType.APPLICATION_JSON)
                            .content("{\"title\" : \"제목입니다.\" , \"content\" : \" 내용입니다.\" }")
                    )
    
                    .andExpect(MockMvcResultMatchers.status().isOk())
                    .andExpect(MockMvcResultMatchers.content().string("{}"))
                    .andDo(MockMvcResultHandlers.print());
            // db -> post 1개 등록
        }
        @Test
        @DisplayName("/posts 요청시 DB에 값이 저장된다")
        void test3() throws Exception {
            //when
            mockMvc.perform(MockMvcRequestBuilders.post("/posts")
                            .contentType(MediaType.APPLICATION_JSON)
                            .content("{\"title\" : \"제목입니다.\" , \"content\" : \"내용입니다.\" }")
                    )
    
                    .andExpect(MockMvcResultMatchers.status().isOk())
                    .andDo(MockMvcResultHandlers.print());
            //then
            Assertions.assertEquals(1L,postRepository.count());
    
            Post post = postRepository.findAll().get(0);
            Assertions.assertEquals("제목입니다.",post.getTitle());
            Assertions.assertEquals("내용입니다.",post.getContent());
    
        }
    
    }
    ```
    

# 6. 작성글 저장 2 - 클래스 분리

1. 컨트롤러
    
    ```jsx
    
    @Slf4j
    @RestController
    @RequiredArgsConstructor
    public class PostController {
    
        private final PostService postService;
    
        //보통 post 요청이면 응답을 따로 안주는 경우가 많음
        //case1. 저장한 데이터 Entity -> response로 응답하기
        //case2. 저장한 데이터의 primary_id -> response로 응답하기
        //  Client에서는 수신한 id를 글 조회 API를 통해서 데이터를 수신받음
        //case3. 응답 필요없음 -> 클라이언트에서 모든 POST(글) 데이터 context를 잘 관리함
        //bad case : 서버에서 -> 반드시 이렇게 할거임
        //  서버에서 차라리 유연하게 대응하는게 좋음 
        //  한 번에 일괄적으로 잘 처리되는 케이스가 없음
        @PostMapping("/posts")
        public void post(@RequestBody @Valid PostCreate request) {
            postService.write(request);
        }
    
        /*
        @PostMapping("/posts")
        public Post post(@RequestBody @Valid PostCreate request) {
            return postService.write(request);
        }
    
        @PostMapping("/posts")
        public Map post(@RequestBody @Valid PostCreate request) {
            Long postId = postService.write(request);
            return Map.of("postId",postId);
        }
    
         */
    }
    
    ```
    
2. 서비스
    
    ```jsx
    
    @Slf4j
    @Service
    @RequiredArgsConstructor
    public class PostService {
    
        private final PostRepository postRepository;
    
        public void write(PostCreate postCreate){
            //Post post = new Post(postCreate.getTitle(), postCreate.getContent());
            Post post = Post.builder()
                    .title(postCreate.getTitle())
                    .content(postCreate.getContent())
                    .build();
            postRepository.save(post);
        }
    }
    ```
    
3. 도메인
    
    ```jsx
    
    @Getter
    @Entity
    @NoArgsConstructor(access = AccessLevel.PROTECTED)
    public class Post {
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private int id;
    
        private String title;
    
        @Lob
        private String content;
    
        @Builder
        public Post(String title, String content) {
            this.title = title;
            this.content = content;
        }
    }
    
    ```
    
4. Dto
    
    ```jsx
    
    @Getter
    @Setter
    @ToString
    public class PostCreate {
    
        @NotBlank(message = "타이틀을 입력해주세요") // validation 라이브러리 추가해야함
        private String title;
    
        @NotBlank(message = "컨텐츠를 입력해주세요") // 값이 들어올떄 자동으로 검증해줌 requestbody 옆에 @Valid 붙여야 자동으로 됨
        private String content;
    
        //생성자를 사용하면 매개변수 위치가 바뀌어버리면 버그를 발견하기 굉장히 어려워짐
        //그렇기에 @Builder를 사용한다
        //빌더는 생성자에다가 다는 것이 좋다
        //빌더를 클래스위에다가 달고 @NoArgsConstructor를 달면 빌더가 망가짐
        @Builder
        public PostCreate(String title, String content) {
            this.title = title;
            this.content = content;
        }
    
        /*
        빌더의 장점
        가독성이 좋다(값 생성에 대한 유연함)
        필요한 값만 받을 수 있다
        객체의 불변성
         */
    }
    
    @Getter
    public class ErrorResponse {
        private final String code;
        private final String message;
        private final Map<String, String> validation = new HashMap<>();
    
        public void addValidation(String field, String defaultMessage) {
            this.validation.put(field, defaultMessage);
        }
    
        @Builder
        public ErrorResponse(String code, String message) {
            this.code = code;
            this.message = message;
        }
    }
    ```
    
5. 테스트
    
    ```jsx
    @AutoConfigureMockMvc
    @SpringBootTest
    class PostControllerTest {
    
        @Autowired
        private ObjectMapper objectMapper;
    
        @Autowired
        private MockMvc mockMvc;
    
        @Autowired
        private PostRepository postRepository;
    
        @BeforeEach
        void clean(){
            postRepository.deleteAll();
        }
    
        @Test
        @DisplayName("/posts 요청시 hello world를 출력한다")
        void test() throws Exception {
            //given
            //PostCreate request = new PostCreate("제목입니다.","내용입니다.");
            PostCreate request = PostCreate.builder()
                    .title("제목입니다.")
                    .content("내용입니다.")
                    .build();
    
            //mapper 객체의 writeValueAsString 메서드는 Java 객체를 JSON 문자열로 변환합니다.
            String json = objectMapper.writeValueAsString(request);
    
            //expected
            mockMvc.perform(MockMvcRequestBuilders.post("/posts")
                            .contentType(MediaType.APPLICATION_JSON)
                            //.content("{\"title\" : \"제목입니다.\" , \"content\" : \" 내용입니다.\" }")
                            //개발자가 읽기도 쓰기도 힘듬
                            //content() 안에는 byte랑 string만 넣을 수 있다
                            .content(json)
                    )
    
                    .andExpect(MockMvcResultMatchers.status().isOk())
                    .andExpect(MockMvcResultMatchers.content().string(""))
                    .andDo(MockMvcResultHandlers.print());
        }
    
        @Test
        @DisplayName("/posts 요청시 title값은 필수다")
        void test2() throws Exception {
            //given
            PostCreate request = PostCreate.builder()
                    .content("내용입니다.") // title을 안 넘기면 null값이 넘어감
                    .build();
    
            String json = objectMapper.writeValueAsString(request);
            //expected
            mockMvc.perform(MockMvcRequestBuilders.post("/posts")
                            .contentType(MediaType.APPLICATION_JSON)
                            .content(json)
                    )
    
                    .andExpect(MockMvcResultMatchers.status().isBadRequest())
                    .andExpect(jsonPath("$.code").value("400"))
                    .andExpect(jsonPath("$.message").value("잘못된 요청입니다"))
                    .andExpect(jsonPath("$.validation.title").value("타이틀을 입력해주세요"))
                    .andDo(MockMvcResultHandlers.print());
        }
    
        @Test
        @DisplayName("/posts 요청시 DB에 값이 저장된다")
        void test3() throws Exception {
            //given
            PostCreate request = PostCreate.builder()
                    .title("제목입니다.")
                    .content("내용입니다.") // title을 안 넘기면 null값이 넘어감
                    .build();
    
            String json = objectMapper.writeValueAsString(request);
            //when
            mockMvc.perform(MockMvcRequestBuilders.post("/posts")
                            .contentType(MediaType.APPLICATION_JSON)
                            .content(json)
                    )
    
                    .andExpect(MockMvcResultMatchers.status().isOk())
                    .andDo(MockMvcResultHandlers.print());
            //then
            Assertions.assertEquals(1L,postRepository.count());
    
            Post post = postRepository.findAll().get(0);
            Assertions.assertEquals("제목입니다.",post.getTitle());
            Assertions.assertEquals("내용입니다.",post.getContent());
    
        }
    
    }
    
    @SpringBootTest
    class PostServiceTest {
    
        @Autowired
        private PostService postService;
    
        @Autowired
        private PostRepository postRepository;
    
        @Test
        @DisplayName("글 작성")
        void test1(){
            //given
            PostCreate postCreate = PostCreate.builder()
                    .title("제목입니다.")
                    .content("내용입니다.")
                    .build();
    
            //when
            postService.write(postCreate);
    
            //then
            Assertions.assertEquals(1L, postRepository.count());
    
            Post post = postRepository.findAll().get(0);
            Assertions.assertEquals("제목입니다.",post.getTitle());
            Assertions.assertEquals("내용입니다.",post.getContent());
        }
    
    }
    ```
    
6. Exception 컨트롤러
    
    ```jsx
    
    @Slf4j
    @ControllerAdvice
    public class ExceptionController {
    
        @ResponseStatus(HttpStatus.BAD_REQUEST)
        @ExceptionHandler(MethodArgumentNotValidException.class)
        @ResponseBody
        public  ErrorResponse MethodArgumentNotValidExceptionHandler(MethodArgumentNotValidException e){
    
            //ErrorResponse response =  new ErrorResponse("400","잘못된 요청입니다");
    
            ErrorResponse response = ErrorResponse.builder()
                    .code("400")
                    .message("잘못된 요청입니다")
                    .build();
            
            for(FieldError fieldError : e.getFieldErrors()){
                response.addValidation(fieldError.getField(),fieldError.getDefaultMessage());
            }
    
            return response;
    
        }
    }
    
    ```
    

# 7. 게시글 조회 1 - 단건조회

1. 컨트롤러
    
    ```jsx
    
    @Slf4j
    @RestController
    @RequiredArgsConstructor
    public class PostController {
    
        private final PostService postService;
    
        @PostMapping("/posts")
        public void post(@RequestBody @Valid PostCreate request) {
            postService.write(request);
        }
    
        @GetMapping("/posts/{postId}")
        public Post get(@PathVariable(name = "postId") Long id) {
            Post post = postService.get(id);
            return post;
        }
    }
    ```
    
2. 서비스
    
    ```jsx
    
    @Slf4j
    @Service
    @RequiredArgsConstructor
    public class PostService {
    
        private final PostRepository postRepository;
    
        public void write(PostCreate postCreate){
            Post post = Post.builder()
                    .title(postCreate.getTitle())
                    .content(postCreate.getContent())
                    .build();
            postRepository.save(post);
        }
    
        public Post get(Long id) {
            Post post  = postRepository.findById(id) //findById Post Entity를 바로 반환해주는게 아니라 옵셔널 데이터로 감싸서 반환해줌
                    .orElseThrow(() -> new IllegalArgumentException("존재하지 않는 글입니다."));
    
            return post;
        }
        /*
         Post post  = postRepository.findById(id)
         findById(id)는 데이터베이스에서 특정 id를 가진 Post 엔티티를 검색하는 메서드입니다.
         이 메서드는 Optional<Post> 타입의 값을 반환합니다. Optional은 결과값이 존재할 수도 있고, 존재하지 않을 수도 있음을 나타내는 컨테이너입니다. 즉, id에 해당하는 Post가 없을 경우, 빈 Optional 객체를 반환합니다.
        
        .orElseThrow(() -> new IllegalArgumentException("존재하지 않는 글입니다."))
        Optional 객체가 가지고 있는 메서드 중 하나입니다.
        orElseThrow()는 Optional 객체에 값이 존재하면 그 값을 반환하고, 값이 존재하지 않으면 orElseThrow에 정의된 예외를 던집니다.
        
        orElseThrow() 메서드가 값이 존재할 때 그 값을 반환하므로, 최종적으로 Optional<Post>에서 Post 객체를 꺼내게 됩니다.
        이 Post 객체는 post 변수에 저장됩니다.
        */
    }
    
    ```
    
3. 테스트
    
    ```jsx
    @SpringBootTest
    class PostServiceTest {
    
        @Autowired
        private PostService postService;
    
        @Autowired
        private PostRepository postRepository;
    
        @BeforeEach
        void clean(){
            postRepository.deleteAll();
        }
    
        @Test
        @DisplayName("글 작성")
        void test1(){
            //given
            PostCreate postCreate = PostCreate.builder()
                    .title("제목입니다.")
                    .content("내용입니다.")
                    .build();
    
            //when
            postService.write(postCreate);
    
            //then
            Assertions.assertEquals(1L, postRepository.count());
    
            Post post = postRepository.findAll().get(0);
            Assertions.assertEquals("제목입니다.",post.getTitle());
            Assertions.assertEquals("내용입니다.",post.getContent());
        }
    
        @Test
        @DisplayName("글 1개 조회")
        void test2(){
            //given
            Post requestpost = Post.builder()
                    .title("foo")
                    .content("bar")
                    .build();
    
            postRepository.save(requestpost);
    
            //when
    
            Post post = postService.get(requestpost.getId());
            //then
    
            Assertions.assertNotNull(post);
            Assertions.assertEquals(1L, postRepository.count());
            Assertions.assertEquals("foo",post.getTitle());
            Assertions.assertEquals("bar",post.getContent());
    
        }
    }
    
    @AutoConfigureMockMvc
    @SpringBootTest
    class PostControllerTest {
    
        @Autowired
        private ObjectMapper objectMapper;
    
        @Autowired
        private MockMvc mockMvc;
    
        @Autowired
        private PostRepository postRepository;
    
        @BeforeEach
        void clean(){
            postRepository.deleteAll();
        }
    
        @Test
        @DisplayName("/posts 요청시 hello world를 출력한다")
        void test() throws Exception {
            //given
            PostCreate request = PostCreate.builder()
                    .title("제목입니다.")
                    .content("내용입니다.")
                    .build();
    
            String json = objectMapper.writeValueAsString(request);
    
            //expected
            mockMvc.perform(MockMvcRequestBuilders.post("/posts")
                            .contentType(MediaType.APPLICATION_JSON)
                            .content(json)
                    )
    
                    .andExpect(MockMvcResultMatchers.status().isOk())
                    .andExpect(MockMvcResultMatchers.content().string(""))
                    .andDo(MockMvcResultHandlers.print());
        }
    
        @Test
        @DisplayName("/posts 요청시 title값은 필수다")
        void test2() throws Exception {
            //given
            PostCreate request = PostCreate.builder()
                    .content("내용입니다.")
                    .build();
    
            String json = objectMapper.writeValueAsString(request);
            //expected
            mockMvc.perform(MockMvcRequestBuilders.post("/posts")
                            .contentType(MediaType.APPLICATION_JSON)
                            .content(json)
                    )
    
                    .andExpect(MockMvcResultMatchers.status().isBadRequest())
                    .andExpect(jsonPath("$.code").value("400"))
                    .andExpect(jsonPath("$.message").value("잘못된 요청입니다"))
                    .andExpect(jsonPath("$.validation.title").value("타이틀을 입력해주세요"))
                    .andDo(MockMvcResultHandlers.print());
        }
    
        @Test
        @DisplayName("/posts 요청시 DB에 값이 저장된다")
        void test3() throws Exception {
            //given
            PostCreate request = PostCreate.builder()
                    .title("제목입니다.")
                    .content("내용입니다.")
                    .build();
    
            String json = objectMapper.writeValueAsString(request);
            //when
            mockMvc.perform(MockMvcRequestBuilders.post("/posts")
                            .contentType(MediaType.APPLICATION_JSON)
                            .content(json)
                    )
    
                    .andExpect(MockMvcResultMatchers.status().isOk())
                    .andDo(MockMvcResultHandlers.print());
            //then
            Assertions.assertEquals(1L, postRepository.count());
    
            Post post = postRepository.findAll().get(0);
            Assertions.assertEquals("제목입니다.", post.getTitle());
            Assertions.assertEquals("내용입니다.", post.getContent());
    
        }
    
        @Test
        @DisplayName("글 1개 조회")
        void test4() throws Exception {
            //given
            Post post = Post.builder()
                    .title("foo")
                    .content("bar")
                    .build();
    
            postRepository.save(post);
    
            //expected
            mockMvc.perform(MockMvcRequestBuilders.get("/posts/{postId}",post.getId())
                            .contentType(MediaType.APPLICATION_JSON)
                    )
                    .andExpect(MockMvcResultMatchers.status().isOk())
                    .andExpect(jsonPath("$.id").value(post.getId()))
                    .andExpect(jsonPath("$.title").value("foo"))
                    .andExpect(jsonPath("$.content").value("bar"))
                    .andDo(MockMvcResultHandlers.print());
        }
    
    }
    ```
    

# 8. 게시글 조회 2 - 응답 클래스 분리

1. 컨트롤러
    
    ```jsx
    
    @Slf4j
    @RestController
    @RequiredArgsConstructor
    public class PostController {
    
        private final PostService postService;
    
        @PostMapping("/posts")
        public void post(@RequestBody @Valid PostCreate request) {
            postService.write(request);
        }
    
    //    @GetMapping("/posts/{postId}")
    //    public Post get(@PathVariable(name = "postId") Long id) {
    //        Post post = postService.get(id);
    //        return post;
    //    }
    // 응답 클래스 분리하기 (서비스 정책에 맞는)
        @GetMapping("/posts/{postId}")
        public PostResponse get(@PathVariable(name = "postId") Long id) {
            //Request 클래스
            //Response 클래스
    
            PostResponse postResponse = postService.get(id);
    
            return postResponse;
        }
    }
    
    ```
    
2. response Dto
    
    ```jsx
    
    /**
     * 서비스 정책에 맞는 클래스
     */
    @Getter
    @Builder
    public class PostResponse {
        private final Long id;
        private final String title;
        private final String content;
    
        @Builder
        public PostResponse(Long id, String title, String content) {
            this.id = id;
            this.title = title.substring(0,Math.min(title.length(), 10));
            this.content = content;
        }
    
    //    이렇게 하거나 아니면 builder 사용하거나
    //    public String getTitle(){
    //        return this.title.substring(0,10);
    //    }
    
    }
    ```
    
3. domain
    
    ```jsx
    
    @Getter
    @Entity
    @NoArgsConstructor(access = AccessLevel.PROTECTED) // 사용이유 일반적인 코드에서는 @Builder를 통해 제공되는 생성자를 사용하도록 유도하는 것입니다.
    public class Post {
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;
    
        private String title;
    
        @Lob
        private String content;
    
        @Builder
        public Post(String title, String content) {
            this.title = title;
            this.content = content;
        }
    
        
        /*
    
        json이 10글자만 가져가도록
        나중에 새로운 기능이 추가되었을 떄 충돌이 발생할 수 있다
    
        엔티티에다가 getter 메서드를 만들 때 가능하면 서비스에 맞는 서비스의 정책을 넣지말것 절대!!!
    
        그럼 클라이언트에게 10글자만 잘라서 줘야하는데 어떻게함?
        
        해결방법 : 응답 클래스를 분리할 것
    
        getTitle 메서드는 Post 객체를 반환할 때 사용되며, title 필드의 값을 10글자만 잘라서 반환하도록 설계되어 있습니다.
        이로 인해 API 호출자가 이 엔티티를 JSON으로 받아볼 때, title 필드의 값이 최대 10글자로 제한됩니다.
         */
        public String getTitle(){
            //return this.title.substring(0,10);
            return this.title;
        }
    }
    
    ```
    
4. 서비스
    
    ```jsx
    
    @Slf4j
    @Service
    @RequiredArgsConstructor
    public class PostService {
    
        private final PostRepository postRepository;
    
        public void write(PostCreate postCreate){
            Post post = Post.builder()
                    .title(postCreate.getTitle())
                    .content(postCreate.getContent())
                    .build();
            postRepository.save(post);
        }
    
    //  public Post get(Long id) {
        public PostResponse get(Long id) {
            Post post  = postRepository.findById(id)
                    .orElseThrow(() -> new IllegalArgumentException("존재하지 않는 글입니다."));
    
            //엔티티를 조회를 해오면 그걸 변환시키기
            PostResponse postResponse = PostResponse.builder()
                    .id(post.getId())
                    .title(post.getTitle())
                    .content(post.getContent())
                    .build();
            //return post;
    
            return postResponse;
        }
    
    }
    
    ```
    
5. 테스트
    
    ```jsx
    
    @AutoConfigureMockMvc
    @SpringBootTest
    class PostControllerTest {
    
        @Autowired
        private ObjectMapper objectMapper;
    
        @Autowired
        private MockMvc mockMvc;
    
        @Autowired
        private PostRepository postRepository;
    
        @BeforeEach
        void clean(){
            postRepository.deleteAll();
        }
    
        @Test
        @DisplayName("/posts 요청시 hello world를 출력한다")
        void test() throws Exception {
            //given
            PostCreate request = PostCreate.builder()
                    .title("제목입니다.")
                    .content("내용입니다.")
                    .build();
    
            String json = objectMapper.writeValueAsString(request);
    
            //expected
            mockMvc.perform(MockMvcRequestBuilders.post("/posts")
                            .contentType(MediaType.APPLICATION_JSON)
                            .content(json)
                    )
    
                    .andExpect(MockMvcResultMatchers.status().isOk())
                    .andExpect(MockMvcResultMatchers.content().string(""))
                    .andDo(MockMvcResultHandlers.print());
        }
    
        @Test
        @DisplayName("/posts 요청시 title값은 필수다")
        void test2() throws Exception {
            //given
            PostCreate request = PostCreate.builder()
                    .content("내용입니다.")
                    .build();
    
            String json = objectMapper.writeValueAsString(request);
            //expected
            mockMvc.perform(MockMvcRequestBuilders.post("/posts")
                            .contentType(MediaType.APPLICATION_JSON)
                            .content(json)
                    )
    
                    .andExpect(MockMvcResultMatchers.status().isBadRequest())
                    .andExpect(jsonPath("$.code").value("400"))
                    .andExpect(jsonPath("$.message").value("잘못된 요청입니다"))
                    .andExpect(jsonPath("$.validation.title").value("타이틀을 입력해주세요"))
                    .andDo(MockMvcResultHandlers.print());
        }
    
        @Test
        @DisplayName("/posts 요청시 DB에 값이 저장된다")
        void test3() throws Exception {
            //given
            PostCreate request = PostCreate.builder()
                    .title("제목입니다.")
                    .content("내용입니다.")
                    .build();
    
            String json = objectMapper.writeValueAsString(request);
            //when
            mockMvc.perform(MockMvcRequestBuilders.post("/posts")
                            .contentType(MediaType.APPLICATION_JSON)
                            .content(json)
                    )
    
                    .andExpect(MockMvcResultMatchers.status().isOk())
                    .andDo(MockMvcResultHandlers.print());
            //then
            Assertions.assertEquals(1L, postRepository.count());
    
            Post post = postRepository.findAll().get(0);
            Assertions.assertEquals("제목입니다.", post.getTitle());
            Assertions.assertEquals("내용입니다.", post.getContent());
    
        }
    
        @Test
        @DisplayName("글 1개 조회")
        void test4() throws Exception {
            //given
            Post post = Post.builder()
                    .title("123456789012345")
                    .content("bar")
                    .build();
    
            postRepository.save(post);
    
            // 클라이언트 요구사항
            // json응답에서 title값 길이를 최대 10글자로 해주세요
            //expected
            mockMvc.perform(MockMvcRequestBuilders.get("/posts/{postId}",post.getId())
                            .contentType(MediaType.APPLICATION_JSON)
                    )
                    .andExpect(MockMvcResultMatchers.status().isOk())
                    .andExpect(jsonPath("$.id").value(post.getId()))
                    .andExpect(jsonPath("$.title").value("1234567890"))
                    .andExpect(jsonPath("$.content").value("bar"))
                    .andDo(MockMvcResultHandlers.print());
        }
    
    }
    
    @SpringBootTest
    class PostServiceTest {
    
        @Autowired
        private PostService postService;
    
        @Autowired
        private PostRepository postRepository;
    
        @BeforeEach
        void clean(){
            postRepository.deleteAll();
        }
    
        @Test
        @DisplayName("글 작성")
        void test1(){
            //given
            PostCreate postCreate = PostCreate.builder()
                    .title("제목입니다.")
                    .content("내용입니다.")
                    .build();
    
            //when
            postService.write(postCreate);
    
            //then
            Assertions.assertEquals(1L, postRepository.count());
    
            Post post = postRepository.findAll().get(0);
            Assertions.assertEquals("제목입니다.",post.getTitle());
            Assertions.assertEquals("내용입니다.",post.getContent());
        }
    
        @Test
        @DisplayName("글 1개 조회")
        void test2(){
            //given
            Post requestpost = Post.builder()
                    .title("foo")
                    .content("bar")
                    .build();
    
            postRepository.save(requestpost);
    
            //when
    
            //Post post = postService.get(requestpost.getId());
            PostResponse response = postService.get(requestpost.getId());
    
            //then
    
            Assertions.assertNotNull(response);
            Assertions.assertEquals(1L, postRepository.count());
            Assertions.assertEquals("foo",response.getTitle());
            Assertions.assertEquals("bar",response.getContent());
    
        }
    }
    ```
    

# 9. 게시글 조회 3 - 게시글 여러개 조회

1. 컨트롤러
    
    ```jsx
    
    @Slf4j
    @RestController
    @RequiredArgsConstructor
    public class PostController {
    
        private final PostService postService;
    
        @PostMapping("/posts")
        public void post(@RequestBody @Valid PostCreate request) {
            postService.write(request);
        }
    
        @GetMapping("/posts/{postId}")
        public PostResponse get(@PathVariable(name = "postId") Long postId) {
            return postService.get(postId);
        }
    
        @GetMapping("/posts")
        public List<PostResponse> getList(){
            return postService.getList();
        }
    }
    ```
    
2. 설정파일
    
    ```jsx
    spring:
      h2:
          console:
            enabled: true
            path: /h2-console
      datasource:
        url : jdbc:h2:mem:gildonglog
        username: sa
        password:
        driver-class-name: org.h2.Driver
    ```
    
    ![image.png](%E1%84%80%E1%85%A2%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20b73bed5326ff4dfcac3147a56ba11b51/image.png)
    
3. 응답 Dto
    
    ```jsx
    /**
     * 서비스 정책에 맞는 클래스
     */
    @Getter
    @Builder
    public class PostResponse {
        private final Long id;
        private final String title;
        private final String content;
    
        //생성자 오버로딩
        public PostResponse(Post post){
            this.id = post.getId();
            this.title = post.getTitle();
            this.content = post.getContent();
        }
    
        @Builder
        public PostResponse(Long id, String title, String content) {
            this.id = id;
            this.title = title.substring(0,Math.min(title.length(), 10));
            this.content = content;
        }
    
    }
    
    ```
    
4. 테스트
    
    ```jsx
    @AutoConfigureMockMvc
    @SpringBootTest
    class PostControllerTest {
    
        @Autowired
        private ObjectMapper objectMapper;
    
        @Autowired
        private MockMvc mockMvc;
    
        @Autowired
        private PostRepository postRepository;
    
        @BeforeEach
        void clean(){
            postRepository.deleteAll();
        }
        @Test
        @DisplayName("글 1개 조회")
        void test4() throws Exception {
            //given
            Post post = Post.builder()
                    .title("123456789012345")
                    .content("bar")
                    .build();
    
            postRepository.save(post);
    
            // 클라이언트 요구사항
            // json응답에서 title값 길이를 최대 10글자로 해주세요
            //expected
            mockMvc.perform(MockMvcRequestBuilders.get("/posts/{postId}",post.getId())
                            .contentType(MediaType.APPLICATION_JSON)
                    )
                    /**
                     *  {id : ... , title : ...}
                     */
                    .andExpect(MockMvcResultMatchers.status().isOk())
                    .andExpect(jsonPath("$.id").value(post.getId()))
                    .andExpect(jsonPath("$.title").value("1234567890"))
                    .andExpect(jsonPath("$.content").value("bar"))
                    .andDo(MockMvcResultHandlers.print());
        }
    
        @Test
        @DisplayName("글 여러개 조회")
        void test5() throws Exception {
            //given
    //        Post post1 = Post.builder()
    //                .title("title_1")
    //                .content("content_1")
    //                .build();
    //
    //        postRepository.save(post1);
    //
    //        Post post2 = Post.builder()
    //                .title("title_2")
    //                .content("content_2")
    //                .build();
    //
    //        postRepository.save(post2);
    
            Post post1 = postRepository.save(Post.builder()
                    .title("title_1")
                    .content("content_1")
                    .build());
    
            Post post2 = postRepository.save(Post.builder()
                    .title("title_2")
                    .content("content_2")
                    .build());
    
            // 클라이언트 요구사항
            // json응답에서 title값 길이를 최대 10글자로 해주세요
            //expected
            mockMvc.perform(MockMvcRequestBuilders.get("/posts")
                            .contentType(MediaType.APPLICATION_JSON)
                    )
                    /**
                     *  [{id : ... , title : ...}, {id : ... , title : ...}]
                     */
                    .andExpect(MockMvcResultMatchers.status().isOk())
                    .andExpect(jsonPath("$.length()", Matchers.is(2)))
                    .andExpect(jsonPath("$[0].id").value(post1.getId()))
                    .andExpect(jsonPath("$[0].title").value("title_1"))
                    .andExpect(jsonPath("$[0].content").value("content_1"))
                    .andExpect(jsonPath("$[1].id").value(post2.getId()))
                    .andExpect(jsonPath("$[1].title").value("title_2"))
                    .andExpect(jsonPath("$[1].content").value("content_2"))
                    .andDo(MockMvcResultHandlers.print());
        }
    
    }
    
    @SpringBootTest
    class PostServiceTest {
    
        @Autowired
        private PostService postService;
    
        @Autowired
        private PostRepository postRepository;
    
        @BeforeEach
        void clean(){
            postRepository.deleteAll();
        }
    
        @Test
        @DisplayName("글 여러개 조회")
        void test3(){
            //given
    //        Post requestpost1 = Post.builder()
    //                .title("foo1")
    //                .content("bar1")
    //                .build();
    //
    //        postRepository.save(requestpost1);
    //
    //        Post requestpost2 = Post.builder()
    //                .title("foo2")
    //                .content("bar2")
    //                .build();
    //
    //        postRepository.save(requestpost2);
    
            postRepository.saveAll(List.of(
                    Post.builder()
                        .title("foo1")
                        .content("bar1")
                        .build(),
                    Post.builder()
                        .title("foo2")
                        .content("bar2")
                        .build()
            ));
    
            //when
           List<PostResponse> posts = postService.getList();
    
            //then
            Assertions.assertEquals(2L, posts.size());
    
        }
        
        
    }
    ```
    
5. 서비스
    
    ```jsx
    
    @Slf4j
    @Service
    @RequiredArgsConstructor
    public class PostService {
    
        private final PostRepository postRepository;
    
        public void write(PostCreate postCreate){
            Post post = Post.builder()
                    .title(postCreate.getTitle())
                    .content(postCreate.getContent())
                    .build();
            postRepository.save(post);
        }
    
        public PostResponse get(Long id) {
            Post post  = postRepository.findById(id)
                    .orElseThrow(() -> new IllegalArgumentException("존재하지 않는 글입니다."));
    
            return PostResponse.builder()
                    .id(post.getId())
                    .title(post.getTitle())
                    .content(post.getContent())
                    .build();
        }
    
        /**
         *
         * stream()
         * findAll()로 반환된 List<Post>를 스트림(Stream)으로 변환합니다.
         * 스트림을 사용하면 컬렉션의 데이터를 병렬 처리하거나 변환할 수 있습니다.
         *
         * map(post -> PostResponse.builder().id(post.getId()).title(post.getTitle()).content(post.getContent()).build())
         * map() 메서드는 스트림의 각 요소를 변환하는 작업을 수행합니다.
         * Post 객체를 PostResponse 객체로 변환합니다.
         *
         * collect(Collectors.toList())
         * map() 메서드를 통해 변환된 스트림을 다시 리스트로 수집합니다.
         * Collectors.toList()는 스트림의 결과를 리스트로 변환합니다.
         *
         * 
         * 해당 방식도 나쁘지 않은데 PostResponse를 생성해야하는 일이 많아지면 반복하기 귀찮음
         */
    //    public List<PostResponse> getList() {
    //        return postRepository.findAll().stream()
    //                .map(post -> PostResponse.builder()
    //                            .id(post.getId())
    //                            .title(post.getTitle())
    //                            .content(post.getContent())
    //                            .build())
    //                .collect(Collectors.toList());
    //    }
    
        public List<PostResponse> getList() {
            return postRepository.findAll().stream()
                    // .map(post -> new PostResponse(post)) 아래와 동일
                    .map(PostResponse::new)
                    .collect(Collectors.toList());
        }
    }
    
    ```
    

# 10. 게시글 조회 4 - 페이징 처리
